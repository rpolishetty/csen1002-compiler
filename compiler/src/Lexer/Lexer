package Lexer;
import Parser.sym;
import java_cup.runtime.Symbol;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
%%
%class Lexer

%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol

%eofval{
	return new Symbol(sym.EOF, null);
%eofval}

%{

  	int charNumber = 0;
  	private void warningReport(String found, String expected, int c){
		
		String inFile = "/Users/Magued/Documents/sheelMaayaaWorkspace/Compiler/src/Lexer/Algebra.decaf";
		try {
			String error = "";
			BufferedReader reader = null;
			reader = new BufferedReader(new FileReader(inFile));
			String line = "";
			for(int i = 1; i <= yyline+1; i++)
				line = reader.readLine().trim();
			
			error += "Warning at line " + (yyline+1) + " char " + (yychar-charNumber+1) + ":\n";
			
			switch(c){
			
			case 1: 
				error += found + " converted to " + expected;
				break;
				
			case 2:
				error += "Invalid Input: '" + found + "' is ignored";
				break;
				
			case 3:
				error += "Missing \" in string: " + found + ", is added";
				break;
			}
				
			error += "\nIn: " + line + "\n";
			
			System.out.println(error);
			} catch (IOException e) {
				e.printStackTrace();
			} 
	}
%}

%line
%char
%state ONELINECOMMENTS
%state MANYLINECOMMENTS
%state STRING

ALPHA=[A-Za-z_]

DIGIT=[0-9]

ALPHA_NUMERIC={ALPHA}|{DIGIT}

BOOLEAN=true|false 

IDENT={ALPHA}({ALPHA_NUMERIC})*

NUMBER=(({DIGIT})+)|(({DIGIT})+.({DIGIT})+)

NUMBERINT=(({DIGIT})+)

NUMBERFLOAT=(({DIGIT})+.({DIGIT})+)

WHITE_SPACE=([\ \b\t\f])+

NEW_LINE= ([\n\r])

STRING=(\"({ALPHA_NUMERIC}|[\ \b\t\f]|{NUMBER}|[;,(){}=+-*/%!|&'\\])*\")

STRINGERROR=(\"({ALPHA_NUMERIC}|[\ \b\t\f]|{NUMBER}|[;,(){}=+-*/%!|&'\\])*)

%%
<YYINITIAL> {STRING} { 
  return new Symbol(sym.ST, yytext());
}
<YYINITIAL> {STRINGERROR} { 
   warningReport(yytext(), "", 3);
   return new Symbol(sym.ST, yytext());
}
<YYINITIAL> {NUMBERINT} { 
  int number = 0;
	for(int k=yy_buffer_start;k < yy_buffer_end; k++){
		number *= 10;
		number += yy_buffer[k]-'0';
	}
  return new Symbol(sym.NM,  "" + number);
}
<YYINITIAL> {NUMBERFLOAT} {
	float floatNumber = 0;
	float decimalPoint = 0;
	for(int k=yy_buffer_start;k < yy_buffer_end; k++){
		if(yy_buffer[k] == '.'){
			decimalPoint=10;
			continue;
		}else if(decimalPoint>=10){
			floatNumber += (yy_buffer[k]-'0')/decimalPoint;
			decimalPoint*=10;
		}else{
			floatNumber *= 10;
			floatNumber += yy_buffer[k]-'0';
		}
	}
  return new Symbol(sym.NM,  "" + floatNumber);
}
<YYINITIAL> "class" { 
  return new Symbol(sym.CLASS, yytext());
}
<YYINITIAL> "else" { 
  return new Symbol(sym.ELSE, yytext());
}
<YYINITIAL> "if" { 
  return new Symbol(sym.IF, yytext());
}
<YYINITIAL> "int" { 
  return new Symbol(sym.INT, yytext());
}
<YYINITIAL> "float" { 
  return new Symbol(sym.FLOAT, yytext());
}
<YYINITIAL> "boolean" { 
  return new Symbol(sym.BOOLEAN, yytext());
}
<YYINITIAL> "String" { 
  return new Symbol(sym.STRING, yytext());
}
<YYINITIAL> "return" { 
  return new Symbol(sym.RETURN, yytext());
}
<YYINITIAL> "static" { 
  return new Symbol(sym.STATIC, yytext());
}
<YYINITIAL> "while" { 
  return new Symbol(sym.WHILE, yytext());
}
<YYINITIAL> "true" { 
  return new Symbol(sym.BL, yytext());
}
<YYINITIAL> "false" { 
  return new Symbol(sym.BL, yytext());
}
<YYINITIAL> {IDENT} { 
  return new Symbol(sym.ID, yytext());
}
<YYINITIAL> {WHITE_SPACE} { }

<YYINITIAL> {NEW_LINE} { 
	charNumber = yychar;
}

<YYINITIAL> ";" { 
  return new Symbol(sym.SM, ";");
} 
<YYINITIAL> "," { 
  return new Symbol(sym.FA, ","); 
} 
<YYINITIAL> "(" { 
  return new Symbol(sym.LP, "(");
} 
<YYINITIAL> ")" { 
  return new Symbol(sym.RP, ")"); 
} 
<YYINITIAL> "{" { 
  return new Symbol(sym.LB, "{");
} 
<YYINITIAL> "}" { 
  return new Symbol(sym.RB, "}");
} 
<YYINITIAL> "=" { 
  return new Symbol(sym.AO, "="); 
} 
<YYINITIAL> "+" { 
  return new Symbol(sym.PO, "+"); 
} 
<YYINITIAL> "-" { 
  return new Symbol(sym.MO, "-");
} 
<YYINITIAL> "*" { 
  return new Symbol(sym.TO, "*");
} 
<YYINITIAL> "/" { 
  return new Symbol(sym.DO, "/");
} 
<YYINITIAL> "%" { 
  return new Symbol(sym.MD, "%");
} 
<YYINITIAL> "==" { 
  return new Symbol(sym.EQ, "==");
} 
<YYINITIAL> "!=" { 
  return new Symbol(sym.NE, "!=");
} 
<YYINITIAL> "|" { 
  warningReport("|", "||", 1);
  return new Symbol(sym.LO, "||"); 
} 
<YYINITIAL> "&" { 
  warningReport("&", "&&", 1);
  return new Symbol(sym.LA, "&&"); 
} 
<YYINITIAL> "||" { 
  return new Symbol(sym.LO, "||"); 
} 
<YYINITIAL> "&&" { 
  return new Symbol(sym.LA, "&&");
}  
<YYINITIAL> "//" {
  yybegin(ONELINECOMMENTS);
}
<YYINITIAL> "/*" {
  yybegin(MANYLINECOMMENTS);
}
<MANYLINECOMMENTS> [^*/] {
}
<MANYLINECOMMENTS> "*/" {
  yybegin(YYINITIAL);
}
<ONELINECOMMENTS> [^\n] {
}
<ONELINECOMMENTS> [\n] {
  yybegin(YYINITIAL);
}
<YYINITIAL> . {
  warningReport(yytext(), "", 2);
  
}



